{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Graphene",
	"patterns": [
		{
			"include": "#comments"
		},
		{
			"include": "#keywords"
		},
		{
			"include": "#strings"
		},
		{
			"include": "#literals"
		},
		{
			"include": "#functions"
		},
		{
			"comment": "Variable declaration",
			"match": "\\b(let|const)\\s+(\\w+)\\s*:\\s*(\\w+)\\b",
			"captures": {
				"1": {
					"name": "keyword.other.graphene"
				},
				"2": {
					"name": "variable.name.graphene"
				},
				"3": {
					"name": "entity.name.type.graphene"
				}
			}
		},
		{
			"comment": "Function call",
			"match": "\\b(\\w+)\\(",
			"captures": {
				"1": {
					"name": "entity.name.function.graphene"
				}
			}
		},
		{
			"comment": "typedef keyword",
			"match": "\\b(typedef)\\b",
			"name": "keyword.other.typedef.graphene"
		},
		{
			"comment": "Generics list after typedef",
			"begin": "(?<=(typedef)\\s*)(\\[)",
			"end": "\\]|$",
			"patterns": [
				{
					"include": "#type-list"
				}
			]
		},
		{
			"comment": "Type after typedef",
			"begin": "(?<=(typedef)(.*?\\])?\\s+)",
			"end": ":|$",
			"patterns": [
				{
					"include": "#type-name"
				}
			]
		},
		{
			"comment": "Struct after typedef",
			"begin": "(?<=(typedef).*?{)",
			"patterns": [
				{
					"include": "#argument-list"
				}
			],
			"end": "}|$"
		},
		{
			"comment": "Last type after typedef",
			"begin": "(?<=(typedef).*?:)(?!\\s*{)",
			"end": "$",
			"patterns": [
				{
					"include": "#type-name"
				}
			]
		}
	],
	"repository": {
		"comments": {
			"patterns": [
				{
					"comment": "Line comment",
					"match": "//.*$\\n?",
					"name": "comment.line.double-slash.graphene"
				},
				{
					"comment": "Block comment",
					"begin": "/\\*",
					"end": "\\*/",
					"name": "comment.block.graphene"
				}
			]
		},
		"keywords": {
			"patterns": [
				{
					"name": "keyword.control.graphene",
					"match": "\\b(if|else|while|for|in|return)\\b"
				},
				{
					"name": "keyword.control.import.graphene",
					"match": "(?<=^|\\s)@require_once\\b"
				}
			]
		},
		"literals": {
			"patterns": [
				{
					"comment": "Decimal constants",
					"match": "\\b\\d+(\\.\\d+)?\\b",
					"name": "constant.numeric.graphene"
				},
				{
					"comment": "Hexadecimal constants",
					"match": "\\b0x[a-fA-F\\d]+\\b",
					"name": "constant.numeric.graphene"
				},
				{
					"comment": "Invalid hexadecimal constants",
					"match": "\\b0x\\b",
					"name": "invalid.illegal.constant.numeric.graphene"
				},
				{
					"comment": "true constant",
					"match": "\\btrue\\b",
					"name": "constant.language.true.graphene"
				},
				{
					"comment": "false constant",
					"match": "\\bfalse\\b",
					"name": "constant.language.true.graphene"
				},
				{
					"comment": "String literals",
					"name": "string.quoted.double.graphene",
					"begin": "\"",
					"end": "\"",
					"patterns": [
						{
							"name": "constant.character.escape.graphene",
							"match": "\\\\."
						}
					]
				}
			]
		},
		"argument-list": {
			"patterns": [
				{
					"include": "#comments"
				},
				{
					"begin": "\\b",
					"end": ":",
					"patterns": [
						{
							"include": "#comments"
						},
						{
							"match": "\\b\\w+\\b",
							"name": "variable.parameter.graphene"
						}
					]
				},
				{
					"begin": "(?<=:)",
					"end": ",|\\)|}",
					"patterns": [
						{
							"include": "#comments"
						},
						{
							"comment": "TODO can we merge this with struct highlighting?",
							"begin": "{",
							"end": "}",
							"patterns": [
								{
									"include": "#argument-list"
								}
							]
						},
						{
							"include": "#type-name"
						}
					]
				}
			]
		},
		"type-list": {
			"patterns": [
				{
					"comment": "Type Name",
					"match": "\\b\\w+\\b",
					"name": "entity.name.type.graphene"
				}
			]
		},
		"type-name": {
			"patterns": [
				{
					"comment": "Built-in named types",
					"match": "\\b(int|isize|iptr|bool|void)\\b",
					"name": "storage.type.graphene"
				},
				{
					"comment": "Built-in sized types",
					"match": "\\b(i|u)(8|16|32|64|128)\\b",
					"name": "storage.type.graphene"
				},
				{
					"comment": "Type identifier",
					"match": "\\b\\w+\\b",
					"name": "entity.name.type.graphene"
				}
			]
		},
		"generics-list": {
			"begin": "\\[",
			"end": "\\]",
			"patterns": [
				{
					"include": "#type-list"
				}
			]
		},
		"functions": {
			"patterns": [
				{
					"include": "#function-declaration"
				}
			],
			"repository": {
				"function-declaration": {
					"begin": "(?<=^|\\s)(function|foreign|@operator|@implicit)\\b",
					"beginCaptures": {
						"0": {
							"name": "keyword.other.function.graphene"
						}
					},
					"end": "(?=(\\b(const|foreign|function|let|typedef)\\b)|@|=)",
					"patterns": [
						{
							"include": "#comments"
						},
						{
							"include": "#function-name"
						},
						{
							"include": "#function-arguments"
						},
						{
							"include": "#function-return-type"
						}
					]
				},
				"function-name": {
					"begin": "\\G",
					"end": ":",
					"patterns": [
						{
							"include": "#generics-list"
						},
						{
							"match": "\\w+",
							"name": "entity.name.function.graphene"
						}
					]
				},
				"function-arguments": {
					"begin": "\\(",
					"end": "(?<=\\))",
					"patterns": [
						{
							"include": "#comments"
						},
						{
							"include": "#argument-list"
						}
					]
				},
				"function-return-type": {
					"begin": "->",
					"end": "(?=(\\b(const|foreign|function|let|typedef)\\b)|@|=)",
					"patterns": [
						{
							"include": "#comments"
						},
						{
							"include": "#type-name"
						}
					]
				}
			}
		}
	},
	"scopeName": "source.graphene"
}
